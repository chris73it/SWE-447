<!DOCTYPE html>

<html>

<head>
    <title>Tiles</title>
    <script src="http://threejs.org/build/three.js"></script>
    <script type="text/javascript" src="../libs/stats.js"></script>
    <script type="text/javascript" src="../libs/dat.gui.js"></script>
    <style>
        body {
            /* set margin to 0 and overflow to hidden, to go fullscreen */
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>

<!-- Div which will hold the Output -->
<div id="WebGL-output">
</div>

<!-- Div which will hold the Stats -->
<div id="Stats-output">
</div>

<!-- Javascript code that runs our Three.js examples -->
<script type="text/javascript">

    // once everything is loaded, we run our Three.js stuff.
    function init() {

        var stats = initStats();

        var currLevel = 0;
        var levels = [];
        var rows = [1, 2, 3, 2, 4, 3];
        var clms = [2, 2, 4, 4, 4, 3];

        // create a scene, that will hold all our elements such as objects, cameras and lights.
        var scene = new THREE.Scene();

        // create a camera, which defines where we're looking at.
        //var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        var camera = new THREE.OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, 1, 1000 );
        // create a render and set the size
        var renderer = new THREE.WebGLRenderer();

        renderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0));
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMapEnabled = true;

        // create cubes
        var SIDE = 80.0;
        var HEIGHT = 5;
        var SPACE = 10;
        function addTileToLevel(level,x,z) {
            var cubeGeometry = new THREE.BoxGeometry(SIDE - SPACE / 2.0, HEIGHT, SIDE - SPACE / 2.0);
            var cubeMaterial = new THREE.MeshLambertMaterial({color: 0xff0000});
            var cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
            cube.castShadow = true;

            // position the cube
            cube.position.x = SIDE * x;
            cube.position.y = 1.0;
            cube.position.z = SIDE * z;

            levels[level][x][z] = cube;
        }

        //level 0
        levels[0] = create2DArray(rows[0], clms[0]);
        addTileToLevel(0,0,0);
        addTileToLevel(0,0,1);

        //level 1
        levels[1] = create2DArray(rows[1], clms[1]);
        addTileToLevel(1,0,0);
        addTileToLevel(1,0,1);
        addTileToLevel(1,1,0);
        addTileToLevel(1,1,1);

        //level 2
        levels[2] = create2DArray(rows[2], clms[2]);
        addTileToLevel(2,0,0);
        addTileToLevel(2,0,1);
        addTileToLevel(2,1,1);
        addTileToLevel(2,1,2);
        addTileToLevel(2,2,2);
        addTileToLevel(2,2,3);

        //level 3
        levels[3] = create2DArray(rows[3], clms[3]);
        addTileToLevel(3,0,0);
        addTileToLevel(3,0,1);
        addTileToLevel(3,0,2);
        addTileToLevel(3,1,1);
        addTileToLevel(3,1,2);
        addTileToLevel(3,1,3);

        //level 4
        levels[4] = create2DArray(rows[4], clms[4]);
        addTileToLevel(4,0,1);
        addTileToLevel(4,1,0);
        addTileToLevel(4,1,1);
        addTileToLevel(4,1,2);
        addTileToLevel(4,2,1);
        addTileToLevel(4,2,2);
        addTileToLevel(4,2,3);
        addTileToLevel(4,3,2);

        //level 5
        levels[5] = create2DArray(rows[5], clms[5]);
        addTileToLevel(5,0,0);
        addTileToLevel(5,0,1);
        addTileToLevel(5,0,2);
        addTileToLevel(5,1,0);
        addTileToLevel(5,1,1);
        addTileToLevel(5,1,2);
        addTileToLevel(5,2,0);
        addTileToLevel(5,2,1);
        addTileToLevel(5,2,2);

        function addTilesToScene(level) {
            for (var x = 0; x < rows[level]; ++x)
            {
                for (var z = 0; z < clms[level]; ++z)
                {
                    if ( levels[level][x][z] != undefined )
                    {
                        scene.add(levels[level][x][z]);
                    }
                }
            }
        }

        function removeAllTilesFromScene(level) {
            for (var x = 0; x < rows[level]; ++x)
            {
                for (var z = 0; z < clms[level]; ++z)
                {
                    if (levels[level][x][z] != undefined)
                    {
                        scene.remove(levels[level][x][z]);
                        levels[level][x][z] = undefined;
                    }
                }
            }
        }

        //removeAllTilesFromScene(currLevel);
        addTilesToScene(currLevel);

        // position and point the camera to the center of the scene
        camera.position.x = -10;
        camera.position.y = 60;
        camera.position.z = 10;
        camera.lookAt(scene.position);

        // add spotlight for the shadows
        var spotLight = new THREE.SpotLight(0xffffff);
        spotLight.position.set(-40, 60, -10);
        spotLight.castShadow = true;
        scene.add(spotLight);

        // add the output of the renderer to the html element
        document.getElementById("WebGL-output").appendChild(renderer.domElement);

        function initStats() {

            var stats = new Stats();

            stats.setMode(0); // 0: fps, 1: ms

            // Align top-left
            stats.domElement.style.position = 'absolute';
            stats.domElement.style.left = '0px';
            stats.domElement.style.top = '0px';

            document.getElementById("Stats-output").appendChild(stats.domElement);

            return stats;
        }

        var raycaster = new THREE.Raycaster();
        var mouse = new THREE.Vector2();

        //Set up callbacks
        window.addEventListener( 'mousemove', onMouseMove, false );
        window.addEventListener( 'mousedown', onMouseDown, false );
        // call the render function
        window.requestAnimationFrame(render);
        //requestAnimationFrame(render);

        function onMouseMove( event ) {

            // calculate mouse position in normalized device coordinates
            // (-1 to +1) for both components

            //console.log("mouse.x: " + event.clientX + ", mouse.y: " + event.clientY);
            mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
            mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
        }

        function onMouseDown() {

            // Update the picking ray with the camera and mouse position
            raycaster.setFromCamera( mouse, camera );

            // calculate coordinates of object intersecting the picking ray
            var intersects = raycaster.intersectObjects( scene.children, false );
            var foundObject = undefined;
            for ( var i = 0; i < intersects.length; i++ )
            {
                if (intersects[ i ].object instanceof THREE.Mesh)
                {
                    foundObject = intersects[i].object;
                    console.log("mouse.x: " + mouse.x + " , mouse.y: " + mouse.y);
                    break;
                }
            }

            if (foundObject === undefined)
            {
                console.log("no object found");
                return;
            }

            var found = false;
            for ( var x = 0; x < rows[currLevel]; x++ )
            {
                for ( var z = 0; z < clms[currLevel]; z++ )
                {
                    if (foundObject === levels[currLevel][x][z])
                    {
                        found = true;
                        break;
                    }
                }
                if (found)
                {
                    console.log("tile x: " + x + " z: " + z);
                    swapTiles(x,z);
                    if (isLevelComplete() == true)
                    {
                        removeAllTilesFromScene(currLevel);

                        if (isGameComplete() == true)
                        {
                            //restart from scratch
                            currLevel = 0;
                        }
                        else
                        {
                            currLevel++;
                        }

                        addTilesToScene(currLevel);
                    }
                    break;
                }
            }
        }

        function isLevelComplete() {
            for ( var x = 0; x < rows[currLevel]; x++ )
            {
                for ( var z = 0; z < clms[currLevel]; z++ )
                {
                    if ( levels[currLevel][x][z] && levels[currLevel][x][z].material.color.getHex() == 0xff0000 )
                    {
                        return false;
                    }
                }
            }
            return true;
        }

        function isGameComplete() {
            if (currLevel == levels.length -1 )
            {
                return true;
            }
            else
            {
                return false;
            }
        }

        function swapTiles(x,z) {
            for ( var _x = 0; _x < rows[currLevel]; _x++ )
            {
                for ( var _z = 0; _z < clms[currLevel]; _z++ )
                {
                    if (x == _x && z == _z)
                    {/*do nothing*/
                        console.log("same x and z: do nothing");
                    }
                    else if (x == _x)
                    {
                        console.log("same x [x:" + _x + ",z:" + _z + "]");
                        swapColor(_x,_z);
                    }
                    else if (z == _z)
                    {
                        console.log("same z [x:" + _x + ",z:" + _z + "]");
                        swapColor(_x,_z);
                    }
                }
            }
        }

        function swapColor(x,z) {
            if ( levels[currLevel][x][z] )
            {
                if (levels[currLevel][x][z].material.color.getHex() == 0x00ff00 )
                {
                    console.log("[x:" + x + ",z:" + z + "] now green: " + levels[currLevel][x][z].material.color.getHex());
                    levels[currLevel][x][z].material.color.setHex( 0xff0000 );
                }
                else
                {
                    console.log("[x:" + x + ",z:" + z + "] now red: " + levels[currLevel][x][z].material.color.getHex());
                    levels[currLevel][x][z].material.color.setHex( 0x00ff00 );
                }
            }
        }

        function render() {

            stats.update();

            renderer.render( scene, camera );

            requestAnimationFrame(render);
        }

        function create2DArray(rows,clms) {
            var arr = [];

            for (var x = 0; x < rows; ++x) {
                arr[x] = [];
                for (var z = 0; z < clms; ++z) {
                    arr[x][z] = undefined;
                }
            }

            return arr;
        }
   }
   window.onload = init;
    
   </script>
</body>
</html>
